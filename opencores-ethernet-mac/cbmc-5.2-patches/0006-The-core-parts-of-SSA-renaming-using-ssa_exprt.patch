From 826b63c297ef5bcceab1b0bd0991edbc7d69d94d Mon Sep 17 00:00:00 2001
From: Michael Tautschnig <mt@debian.org>
Date: Thu, 28 Aug 2014 11:45:12 +0200
Subject: [PATCH 06/18] The core parts of SSA renaming using ssa_exprt

---
 src/goto-symex/goto_symex.h                |   1 +
 src/goto-symex/goto_symex_state.cpp        | 374 +++++++++++------------------
 src/goto-symex/goto_symex_state.h          | 180 +++++---------
 src/goto-symex/symex_atomic_section.cpp    |   9 +-
 src/goto-symex/symex_builtin_functions.cpp |   7 +-
 src/goto-symex/symex_dead.cpp              |  30 ++-
 src/goto-symex/symex_decl.cpp              |  58 +++--
 src/goto-symex/symex_function_call.cpp     |  44 +++-
 src/goto-symex/symex_goto.cpp              |  28 +--
 src/goto-symex/symex_main.cpp              |   5 +-
 src/goto-symex/symex_start_thread.cpp      |  48 ++--
 11 files changed, 327 insertions(+), 457 deletions(-)

diff --git a/src/goto-symex/goto_symex.h b/src/goto-symex/goto_symex.h
index 66b43e3..e520bce 100644
--- a/src/goto-symex/goto_symex.h
+++ b/src/goto-symex/goto_symex.h
@@ -154,6 +154,7 @@ protected:
   virtual void symex_atomic_begin(statet &state);
   virtual void symex_atomic_end(statet &state);  
   virtual void symex_decl(statet &state);
+  virtual void symex_decl(statet &state, const symbol_exprt &expr);
   virtual void symex_dead(statet &state);
   virtual void symex_return(statet &state);
 
diff --git a/src/goto-symex/goto_symex_state.cpp b/src/goto-symex/goto_symex_state.cpp
index d0612f1..91bff04 100644
--- a/src/goto-symex/goto_symex_state.cpp
+++ b/src/goto-symex/goto_symex_state.cpp
@@ -76,49 +76,41 @@ Function: goto_symex_statet::level0t::operator()
 
 \*******************************************************************/
 
-irep_idt goto_symex_statet::level0t::operator()(
-  const irep_idt &identifier,
+void goto_symex_statet::level0t::operator()(
+  ssa_exprt &ssa_expr,
   const namespacet &ns,
   unsigned thread_nr)
 {
   // already renamed?
-  if(original_identifiers.find(identifier)!=original_identifiers.end())
-    return identifier;
+  if(!ssa_expr.get_level_0().empty())
+    return;
+
+  const irep_idt &obj_identifier=ssa_expr.get_object_name();
 
   // guards are not L0-renamed
-  if(identifier=="goto_symex::\\guard")
-  {
-    original_identifiers[identifier]=identifier;
-    return identifier;
-  }
+  if(obj_identifier=="goto_symex::\\guard")
+    return;
 
   const symbolt *s;
-  if(ns.lookup(identifier, s))
+
+  if(ns.lookup(obj_identifier, s))
   {
-    std::cerr << "level0: failed to find " << identifier << std::endl;
+    std::cerr << "level0: failed to find " << obj_identifier << std::endl;
     abort();
   }
   
   // don't rename shared variables or functions
   if(s->type.id()==ID_code ||
      s->is_shared())
-  {
-    original_identifiers[identifier]=identifier;
-    return identifier;
-  }
+    return;
 
   // rename!    
-  irep_idt new_identifier=name(identifier, thread_nr);
-  
-  // remember that
-  original_identifiers[new_identifier]=identifier;
-
-  return new_identifier;
+  ssa_expr.set_level_0(thread_nr);
 }
 
 /*******************************************************************\
 
-Function: goto_symex_statet::renaming_levelt::current_count
+Function: goto_symex_statet::level1t::operator()
 
   Inputs:
 
@@ -128,11 +120,19 @@ Function: goto_symex_statet::renaming_levelt::current_count
 
 \*******************************************************************/
 
-unsigned goto_symex_statet::renaming_levelt::current_count(
-  const irep_idt &identifier) const
+void goto_symex_statet::level1t::operator()(ssa_exprt &ssa_expr)
 {
-  current_namest::const_iterator it=current_names.find(identifier);
-  return it==current_names.end()?0:it->second;
+  // already renamed?
+  if(!ssa_expr.get_level_1().empty())
+    return;
+
+  const irep_idt l0_name=ssa_expr.get_l1_object_identifier();
+
+  current_namest::const_iterator it=current_names.find(l0_name);
+  if(it==current_names.end()) return;
+
+  // rename!
+  ssa_expr.set_level_1(it->second.second);
 }
 
 /*******************************************************************\
@@ -286,21 +286,18 @@ Function: goto_symex_statet::assignment
 \*******************************************************************/
 
 void goto_symex_statet::assignment(
-  symbol_exprt &lhs, // L0/L1
+  ssa_exprt &lhs, // L0/L1
   const exprt &rhs,  // L2
   const namespacet &ns,
   bool rhs_is_simplified,
   bool record_value)
 {
-  assert(lhs.id()==ID_symbol);
-
   // the type might need renaming
   rename(lhs.type(), ns);
 
-  irep_idt identifier=lhs.get_identifier();
-    
   // identifier should be l0 or l1, make sure it's l1
-  irep_idt l1_identifier=level1(identifier);
+  rename(lhs, ns, L1);
+  irep_idt l1_identifier=lhs.get_identifier();
 
   #if 0  
   assert(l1_identifier != get_original_name(l1_identifier)
@@ -310,9 +307,11 @@ void goto_symex_statet::assignment(
       || has_prefix(id2string(l1_identifier), "symex_dynamic::dynamic_object"));
   #endif
 
-  // do the l2 renaming 
-  irep_idt new_l2_name=level2.increase_counter(l1_identifier);
-  lhs.set_identifier(new_l2_name);
+  // do the l2 renaming
+  if(level2.current_names.find(l1_identifier)==level2.current_names.end())
+    level2.current_names[l1_identifier]=std::make_pair(lhs, 0);
+  level2.increase_counter(l1_identifier);
+  set_ssa_indices(lhs, ns, L2);
 
   // in case we happen to be multi-threaded, record the memory access
   bool is_shared=l2_thread_write_encoding(lhs, ns);
@@ -328,16 +327,16 @@ void goto_symex_statet::assignment(
     // update value sets
     value_sett::expr_sett rhs_value_set;
     exprt l1_rhs(rhs);
-    level2.get_original_name(l1_rhs);
+    get_l1_name(l1_rhs);
 
-    symbol_exprt l1_lhs(l1_identifier, lhs.type());
-    level2.get_original_name(l1_lhs.type());
+    ssa_exprt l1_lhs(lhs);
+    get_l1_name(l1_lhs);
 
     value_set.assign(l1_lhs, l1_rhs, ns, rhs_is_simplified, is_shared);
   }
   
   #if 0
-  std::cout << "Assigning " << identifier << std::endl;
+  std::cout << "Assigning " << l1_identifier << std::endl;
   value_set.output(ns, std::cout);
   std::cout << "**********************" << std::endl;
   #endif
@@ -360,7 +359,7 @@ void goto_symex_statet::propagationt::operator()(exprt &expr)
   if(expr.id()==ID_symbol)
   {
     valuest::const_iterator it=
-      values.find(to_symbol_expr(expr).get_identifier());
+      values.find(expr.get(ID_identifier));
     if(it!=values.end())
       expr=it->second;
   }
@@ -378,7 +377,7 @@ void goto_symex_statet::propagationt::operator()(exprt &expr)
 
 /*******************************************************************\
 
-Function: goto_symex_statet::rename_identifier
+Function: goto_symex_statet::set_ssa_indices
 
   Inputs:
 
@@ -388,31 +387,30 @@ Function: goto_symex_statet::rename_identifier
 
 \*******************************************************************/
 
-irep_idt goto_symex_statet::rename_identifier(
-  const irep_idt &identifier,
+void goto_symex_statet::set_ssa_indices(
+  ssa_exprt &ssa_expr,
   const namespacet &ns,
   levelt level)
 {
   switch(level)
   {
   case L0:
-    return level0(identifier, ns, source.thread_nr);
+    level0(ssa_expr, ns, source.thread_nr);
+    break;
     
   case L1:
-    {
-      if(level2.is_renamed(identifier)) return identifier;
-      if(level1.is_renamed(identifier)) return identifier;
-      irep_idt l0_identifier=level0(identifier, ns, source.thread_nr);
-      return level1(l0_identifier);
-    }
+    if(!ssa_expr.get_level_2().empty()) return;
+    if(!ssa_expr.get_level_1().empty()) return;
+    level0(ssa_expr, ns, source.thread_nr);
+    level1(ssa_expr);
+    break;
   
   case L2:
-    {
-      if(level2.is_renamed(identifier)) return identifier;
-      irep_idt l0_identifier=level0(identifier, ns, source.thread_nr);
-      irep_idt l1_identifier=level1(l0_identifier);
-      return level2(l1_identifier); // L2
-    }
+    if(!ssa_expr.get_level_2().empty()) return;
+    level0(ssa_expr, ns, source.thread_nr);
+    level1(ssa_expr);
+    ssa_expr.set_level_2(level2.current_count(ssa_expr.get_identifier()));
+    break;
     
   default:
     assert(false);
@@ -440,49 +438,49 @@ void goto_symex_statet::rename(
   
   rename(expr.type(), ns, level);
 
-  if(expr.id()==ID_symbol)
+  if(expr.id()==ID_symbol &&
+     expr.get_bool(ID_C_SSA_symbol))
   {
-    // we never rename function symbols
-    if(ns.follow(expr.type()).id()==ID_code)
-      return;
-  
-    const irep_idt identifier=to_symbol_expr(expr).get_identifier();
+    ssa_exprt &ssa=to_ssa_expr(expr);
 
     if(level==L0 || level==L1)
-    {
-      const irep_idt new_name=rename_identifier(identifier, ns, level);
-      to_symbol_expr(expr).set_identifier(new_name);
-    }  
+      set_ssa_indices(ssa, ns, level);
     else if(level==L2)
     {
-      if(l2_thread_read_encoding(to_symbol_expr(expr), ns))
+      set_ssa_indices(ssa, ns, L1);
+
+      if(l2_thread_read_encoding(ssa, ns))
       {
         // renaming taken care of by l2_thread_encoding
       }
-      else if(level2.is_renamed(identifier))
+      else if(!ssa.get_level_2().empty())
       {
         // already at L2
       }
       else
       {
-        irep_idt l1_identifier=rename_identifier(identifier, ns, L1);
-
         // We also consider propagation if we go up to L2.
         // L1 identifiers are used for propagation!
         propagationt::valuest::const_iterator p_it=
-          propagation.values.find(l1_identifier);
+          propagation.values.find(ssa.get_identifier());
 
         if(p_it!=propagation.values.end())
           expr=p_it->second; // already L2
         else
-        {
-          irep_idt new_name=level2(l1_identifier); // L2
-          to_symbol_expr(expr).set_identifier(new_name);
-        }
+          set_ssa_indices(ssa, ns, L2);
       }
     }
     
   }
+  else if(expr.id()==ID_symbol)
+  {
+    // we never rename function symbols
+    if(ns.follow(expr.type()).id()==ID_code)
+      return;
+
+    expr=ssa_exprt(expr);
+    rename(expr, ns, level);
+  }
   else if(expr.id()==ID_address_of)
   {
     assert(expr.operands().size()==1);
@@ -509,7 +507,7 @@ Function: goto_symex_statet::l2_thread_read_encoding
 \*******************************************************************/
 
 bool goto_symex_statet::l2_thread_read_encoding(
-  symbol_exprt &expr,
+  ssa_exprt &expr,
   const namespacet &ns)
 {
   if(!record_events)
@@ -519,17 +517,15 @@ bool goto_symex_statet::l2_thread_read_encoding(
   if(threads.size()<=1)
     return false;
 
-  const irep_idt &identifier=expr.get_identifier();
-  const irep_idt &orig_identifier=get_original_name(identifier);
-
   // is it a shared object?
-  if(orig_identifier=="goto_symex::\\guard" ||
-     !ns.lookup(orig_identifier).is_shared())
+  const irep_idt &obj_identifier=expr.get_object_name();
+  if(obj_identifier=="goto_symex::\\guard" ||
+     !ns.lookup(obj_identifier).is_shared())
     return false;
 
-  const irep_idt l1_identifier=rename_identifier(orig_identifier, ns, L1);
-  symbol_exprt ssa_l1=expr;
-  ssa_l1.set_identifier(l1_identifier);
+  ssa_exprt ssa_l1=expr;
+  ssa_l1.remove_level_2();
+  const irep_idt &l1_identifier=ssa_l1.get_identifier();
 
   // see whether we are within an atomic section
   if(atomic_section_id!=0)
@@ -586,16 +582,17 @@ bool goto_symex_statet::l2_thread_read_encoding(
       cond=or_exprt(no_write.op(), cond);
 
     if_exprt tmp(cond, ssa_l1, ssa_l1);
-    level2(to_symbol_expr(tmp.true_case()));
+    set_ssa_indices(to_ssa_expr(tmp.true_case()), ns, L2);
 
     if(a_s_read.second.empty())
     {
+      if(level2.current_names.find(l1_identifier)==level2.current_names.end())
+        level2.current_names[l1_identifier]=std::make_pair(ssa_l1, 0);
       level2.increase_counter(l1_identifier);
       a_s_read.first=level2.current_count(l1_identifier);
     }
 
-    to_symbol_expr(tmp.false_case()).set_identifier(
-      level2.name(l1_identifier, a_s_read.first));
+    to_ssa_expr(tmp.false_case()).set_level_2(a_s_read.first);
 
     if(cond.is_false())
     {
@@ -605,17 +602,21 @@ bool goto_symex_statet::l2_thread_read_encoding(
 
     const bool record_events_bak=record_events;
     record_events=false;
-    assignment(expr, tmp, ns, true, true);
+    assignment(ssa_l1, tmp, ns, true, true);
     record_events=record_events_bak;
 
-    symbol_exprt lhs=ns.lookup(orig_identifier).symbol_expr();
     symex_target->assignment(
       guard.as_expr(),
-      expr, lhs, expr, lhs,
+      ssa_l1,
+      ssa_l1,
+      ssa_l1.get_original_expr(),
       tmp,
       source,
       symex_targett::PHI);
 
+    set_ssa_indices(ssa_l1, ns, L2);
+    expr=ssa_l1;
+
     a_s_read.second.push_back(guard);
     if(!no_write.op().is_false())
       a_s_read.second.back().add(no_write);
@@ -624,16 +625,17 @@ bool goto_symex_statet::l2_thread_read_encoding(
   }
 
   // produce a fresh L2 name
-  irep_idt new_l2_name=level2.increase_counter(l1_identifier);
-  expr.set_identifier(new_l2_name);
+  if(level2.current_names.find(l1_identifier)==level2.current_names.end())
+    level2.current_names[l1_identifier]=std::make_pair(ssa_l1, 0);
+  level2.increase_counter(l1_identifier);
+  set_ssa_indices(ssa_l1, ns, L2);
+  expr=ssa_l1;
 
   // and record that
   assert(symex_target!=NULL);
-  symbol_exprt original_symbol(orig_identifier, expr.type());
   symex_target->shared_read(
     guard.as_expr(),
     expr,
-    original_symbol,
     atomic_section_id,
     source);
 
@@ -653,38 +655,32 @@ Function: goto_symex_statet::l2_thread_write_encoding
 \*******************************************************************/
 
 bool goto_symex_statet::l2_thread_write_encoding(
-  const symbol_exprt &expr,
+  const ssa_exprt &expr,
   const namespacet &ns)
 {
   if(!record_events)
     return false;
 
-  const irep_idt &identifier=expr.get_identifier();
-  const irep_idt &orig_identifier=get_original_name(identifier);
-
   // is it a shared object?
-  if(orig_identifier=="goto_symex::\\guard" ||
-     !ns.lookup(orig_identifier).is_shared())
+  const irep_idt &obj_identifier=expr.get_object_name();
+  if(obj_identifier=="goto_symex::\\guard" ||
+     !ns.lookup(obj_identifier).is_shared())
     return false; // not shared
     
   // see whether we are within an atomic section
   if(atomic_section_id!=0)
   {
-    const irep_idt l1_identifier=rename_identifier(orig_identifier, ns, L1);
-    symbol_exprt ssa_l1=expr;
-    ssa_l1.set_identifier(l1_identifier);
+    ssa_exprt ssa_l1=expr;
+    ssa_l1.remove_level_2();
 
     written_in_atomic_section[ssa_l1].push_back(guard);
     return false;
   }
 
   // record a shared write
-  symbol_exprt original_symbol(orig_identifier, expr.type());
-
   symex_target->shared_write(
     guard.as_expr(),
     expr,
-    original_symbol,
     atomic_section_id,
     source);
 
@@ -711,12 +707,18 @@ void goto_symex_statet::rename_address(
 {
   rename(expr.type(), ns, level);
 
-  if(expr.id()==ID_symbol)
+  if(expr.id()==ID_symbol &&
+     expr.get_bool(ID_C_SSA_symbol))
   {
+    ssa_exprt &ssa=to_ssa_expr(expr);
+
     // only do L1!
-    irep_idt identifier=to_symbol_expr(expr).get_identifier();
-    identifier=rename_identifier(identifier, ns, L1);
-    to_symbol_expr(expr).set_identifier(identifier);
+    set_ssa_indices(ssa, ns, L1);
+  }
+  else if(expr.id()==ID_symbol)
+  {
+    expr=ssa_exprt(expr);
+    rename_address(expr, ns, level);
   }
   else
   {
@@ -779,7 +781,14 @@ void goto_symex_statet::rename(
           type.id()==ID_union ||
           type.id()==ID_class)
   {
-    // TODO
+    struct_union_typet &s_u_type=to_struct_union_type(type);
+    struct_union_typet::componentst &components=s_u_type.components();
+
+    for(struct_union_typet::componentst::iterator
+        it=components.begin();
+        it!=components.end();
+        ++it)
+      rename(it->type(), ns, level);
   }
   else if(type.id()==ID_pointer)
   {
@@ -797,28 +806,6 @@ void goto_symex_statet::rename(
 
 /*******************************************************************\
 
-Function: goto_symex_statet::renaming_levelt::print
-
-  Inputs:
-
- Outputs:
-
- Purpose:
-
-\*******************************************************************/
-
-void goto_symex_statet::renaming_levelt::print(std::ostream &out) const
-{
-  for(current_namest::const_iterator
-      it=current_names.begin();
-      it!=current_names.end();
-      it++)
-    out << it->first << " --> "
-        << name(it->first, it->second) << std::endl;
-}
-
-/*******************************************************************\
-
 Function: goto_symex_statet::get_original_name
 
   Inputs:
@@ -833,68 +820,15 @@ void goto_symex_statet::get_original_name(exprt &expr) const
 {
   get_original_name(expr.type());
 
-  Forall_operands(it, expr)
-    get_original_name(*it);
-
-  if(expr.id()==ID_symbol)
-  {
-    level2.get_original_name(expr);
-    level1.get_original_name(expr);
-    level0.get_original_name(expr);
-  }
-}
-
-/*******************************************************************\
-
-Function: goto_symex_statet::renaming_levelt::get_original_name
-
-  Inputs:
-
- Outputs:
-
- Purpose:
-
-\*******************************************************************/
-
-void goto_symex_statet::renaming_levelt::get_original_name(exprt &expr) const
-{
-  get_original_name(expr.type());
-
-  Forall_operands(it, expr)
-    get_original_name(*it);
-
-  if(expr.id()==ID_symbol)
-  {
-    original_identifierst::const_iterator it=
-      original_identifiers.find(expr.get(ID_identifier));
-    if(it==original_identifiers.end()) return;
-    assert(it->second!="");
-    expr.set(ID_identifier, it->second);
-  }
+  if(expr.id()==ID_symbol &&
+     expr.get_bool(ID_C_SSA_symbol))
+    expr=to_ssa_expr(expr).get_original_expr();
+  else
+    Forall_operands(it, expr)
+      get_original_name(*it);
 }
 
 /*******************************************************************\
-
-Function: goto_symex_statet::renaming_levelt::get_original_name
-
-  Inputs:
-
- Outputs:
-
- Purpose:
-
-\*******************************************************************/
-
-const irep_idt &goto_symex_statet::renaming_levelt::get_original_name(
-  const irep_idt &identifier) const
-{
-  original_identifierst::const_iterator it=
-    original_identifiers.find(identifier);
-  if(it==original_identifiers.end()) return identifier;
-  return it->second;
-}
-
- /*******************************************************************\
  
 Function: goto_symex_statet::get_original_name
 
@@ -919,40 +853,14 @@ void goto_symex_statet::get_original_name(typet &type) const
           type.id()==ID_union ||
           type.id()==ID_class)
   {
-    // TODO
-  }
-  else if(type.id()==ID_pointer)
-  {
-    get_original_name(type.subtype());
-  }
-}
-
-/*******************************************************************\
-
-Function: goto_symex_statet::renaming_levelt::get_original_name
-
-  Inputs:
-
- Outputs:
-
- Purpose:
-
-\*******************************************************************/
+    struct_union_typet &s_u_type=to_struct_union_type(type);
+    struct_union_typet::componentst &components=s_u_type.components();
 
-void goto_symex_statet::renaming_levelt::get_original_name(typet &type) const
-{
-  // rename all the symbols back to their original name
-
-  if(type.id()==ID_array)
-  {
-    get_original_name(type.subtype());
-    get_original_name(to_array_type(type).size());
-  }
-  else if(type.id()==ID_struct ||
-          type.id()==ID_union ||
-          type.id()==ID_class)
-  {
-    // TODO
+    for(struct_union_typet::componentst::iterator
+        it=components.begin();
+        it!=components.end();
+        ++it)
+      get_original_name(it->type());
   }
   else if(type.id()==ID_pointer)
   {
@@ -962,7 +870,7 @@ void goto_symex_statet::renaming_levelt::get_original_name(typet &type) const
 
 /*******************************************************************\
 
-Function: goto_symex_statet::get_original_name
+Function: goto_symex_statet::get_l1_name
 
   Inputs:
 
@@ -972,12 +880,16 @@ Function: goto_symex_statet::get_original_name
 
 \*******************************************************************/
 
-const irep_idt &goto_symex_statet::get_original_name(
-  const irep_idt &identifier) const
+void goto_symex_statet::get_l1_name(exprt &expr) const
 {
-  return level0.get_original_name(
-         level1.get_original_name(
-         level2.get_original_name(identifier)));
+  // do not reset the type !
+
+  if(expr.id()==ID_symbol &&
+     expr.get_bool(ID_C_SSA_symbol))
+    to_ssa_expr(expr).remove_level_2();
+  else
+    Forall_operands(it, expr)
+      get_l1_name(*it);
 }
 
 /*******************************************************************\
diff --git a/src/goto-symex/goto_symex_state.h b/src/goto-symex/goto_symex_state.h
index 4dfc19f..e296332 100644
--- a/src/goto-symex/goto_symex_state.h
+++ b/src/goto-symex/goto_symex_state.h
@@ -14,6 +14,7 @@ Author: Daniel Kroening, kroening@kroening.com
 #include <util/guard.h>
 #include <util/std_expr.h>
 #include <util/i2string.h>
+#include <util/ssa_expr.h>
 
 #include <pointer-analysis/value_set.h>
 #include <goto-programs/goto_functions.h>
@@ -45,97 +46,39 @@ public:
   
   struct renaming_levelt
   {
-  public:
-    virtual irep_idt current_name(const irep_idt &identifier) const=0;
-    virtual irep_idt name(const irep_idt &identifier, unsigned count) const=0;
     virtual ~renaming_levelt() { }
 
-    typedef std::map<irep_idt, unsigned> current_namest;
+    typedef std::map<irep_idt, std::pair<ssa_exprt, unsigned> > current_namest;
     current_namest current_names;
     
-    void remove(const irep_idt &identifier) { current_names.erase(identifier); }
-    const irep_idt &get_original_name(const irep_idt &identifier) const;
-    void get_original_name(exprt &expr) const;
-    void get_original_name(typet &type) const;
-    void print(std::ostream &out) const;
-    unsigned current_count(const irep_idt &identifier) const;
-    
-    irep_idt operator()(const irep_idt &identifier)
+    unsigned current_count(const irep_idt &identifier) const
     {
-      // see if it's already renamed
-      if(is_renamed(identifier)) return identifier;
-
-      // record
-      irep_idt i=current_name(identifier);
-      original_identifiers[i]=identifier;
-      return i;
+      current_namest::const_iterator it=
+        current_names.find(identifier);
+      return it==current_names.end()?0:it->second.second;
     }
 
-    inline void operator()(symbol_exprt &expr)
-    {
-      expr.set_identifier(operator()(expr.get_identifier()));
-    }
-    
-    irep_idt rename_identifier(const irep_idt &identifier, unsigned count)
-    {
-      current_names[identifier]=count;
-      irep_idt new_name=name(identifier, count);
-      original_identifiers[new_name]=identifier;
-      return new_name;
-    }
-    
-    irep_idt increase_counter(const irep_idt &identifier)
-    {
-      return rename_identifier(identifier, current_names[identifier]+1);
-    }
-    
-    inline bool is_renamed(const irep_idt &identifier) const
-    {
-      return original_identifiers.find(identifier)!=original_identifiers.end();
-    }
-    
-    void restore_from(const current_namest &other)
+    void increase_counter(const irep_idt &identifier)
     {
-      for(current_namest::const_iterator
-          it=other.begin();
-          it!=other.end();
-          it++)
-      {
-        // could be done faster exploing ordering
-        current_names[it->first]=it->second;
-      }
+      assert(current_names.find(identifier)!=current_names.end());
+      ++current_names[identifier].second;
     }
 
-    void get_variables(std::set<irep_idt> &vars) const
+    void get_variables(hash_set_cont<ssa_exprt, irep_hash> &vars) const
     {
       for(current_namest::const_iterator it=current_names.begin();
           it!=current_names.end();
           it++)
-        vars.insert(it->first);
+        vars.insert(it->second.first);
     }
-
-  protected:
-    original_identifierst original_identifiers;
   };
   
   // level 0 -- threads!
   // renaming built for one particular interleaving
   struct level0t:public renaming_levelt
   {
-  public:
-    virtual irep_idt name(const irep_idt &identifier, unsigned thread_nr) const
-    {
-      return id2string(identifier)+"!"+i2string(thread_nr);
-    }
-
-    virtual irep_idt current_name(const irep_idt &identifier) const
-    { // never called
-      assert(false);
-      return irep_idt();
-    }
-
-    irep_idt operator()(
-      const irep_idt &identifier,
+    void operator()(
+      ssa_exprt &ssa_expr,
       const namespacet &ns,
       unsigned thread_nr);
 
@@ -148,26 +91,27 @@ public:
   
   struct level1t:public renaming_levelt
   {
-  public:
-    virtual irep_idt name(const irep_idt &identifier, unsigned frame) const
-    {
-      return id2string(identifier)+"@"+i2string(frame);
-    }
-    
-    virtual irep_idt current_name(const irep_idt &identifier) const
-    {
-      // see if it's already renamed
-      if(is_renamed(identifier))
-        return identifier;
+    void operator()(ssa_exprt &ssa_expr);
 
-      // rename only if needed
-      const current_namest::const_iterator it=
-        current_names.find(identifier);
-    
-      if(it==current_names.end())
-        return identifier;
-      else
-        return name(identifier, it->second);
+    void restore_from(const current_namest &other)
+    {
+      current_namest::iterator it=current_names.begin();
+      for(current_namest::const_iterator
+          ito=other.begin();
+          ito!=other.end();
+          ++ito)
+      {
+        while(it!=current_names.end() && it->first<ito->first)
+          ++it;
+        if(it==current_names.end() || ito->first<it->first)
+          current_names.insert(it, *ito);
+        else if(it!=current_names.end())
+        {
+          assert(it->first==ito->first);
+          it->second=ito->second;
+          ++it;
+        }
+      }
     }
 
     level1t() { }
@@ -178,22 +122,6 @@ public:
 
   struct level2t:public renaming_levelt
   {
-  public:
-    virtual irep_idt name(const irep_idt &identifier, unsigned count) const
-    {
-      return id2string(identifier)+"#"+i2string(count);
-    }
-
-    virtual irep_idt current_name(const irep_idt &identifier) const
-    {
-      // see if it's already renamed
-      if(is_renamed(identifier))
-        return identifier;
-
-      // _always_ rename
-      return name(identifier, current_count(identifier));
-    }
-    
     level2t() { }
     virtual ~level2t() { }
   } level2;
@@ -216,14 +144,10 @@ public:
   typedef enum { L0=0, L1=1, L2=2 } levelt;
 
   // performs renaming _up to_ the given level
-  irep_idt rename_identifier(const irep_idt &identifier, const namespacet &ns, levelt level=L2);
   void rename(exprt &expr, const namespacet &ns, levelt level=L2);
-  void rename(typet &type, const namespacet &ns, levelt level=L2);
-  
-  void rename_address(exprt &expr, const namespacet &ns, levelt level);
   
   void assignment(
-    symbol_exprt &lhs, // L0/L1
+    ssa_exprt &lhs, // L0/L1
     const exprt &rhs,  // L2
     const namespacet &ns,
     bool rhs_is_simplified,
@@ -234,10 +158,21 @@ public:
   bool constant_propagation_reference(const exprt &expr) const;
 
   // undoes all levels of renaming
-  const irep_idt &get_original_name(const irep_idt &identifier) const;
   void get_original_name(exprt &expr) const;
   void get_original_name(typet &type) const;
+protected:
+  void rename(typet &type, const namespacet &ns, levelt level=L2);
+  void rename_address(exprt &expr, const namespacet &ns, levelt level);
+
+  void set_ssa_indices(ssa_exprt &expr, const namespacet &ns, levelt level=L2);
+  // only required for value_set.assign
+  void get_l1_name(exprt &expr) const;
+
+  // this maps L1 names to (L2) types
+  typedef hash_map_cont<irep_idt, typet, irep_id_hash> l1_typest;
+  l1_typest l1_types;
   
+public:
   // uses level 1 names, and is used to
   // do dereferencing
   value_sett value_set;
@@ -263,25 +198,20 @@ public:
     }
 
     // the below replicate levelt2 member functions
-    void level2_get_variables(std::set<irep_idt> &vars) const
+    void level2_get_variables(hash_set_cont<ssa_exprt, irep_hash> &vars) const
     {
       for(level2t::current_namest::const_iterator
           it=level2_current_names.begin();
           it!=level2_current_names.end();
           it++)
-        vars.insert(it->first);
+        vars.insert(it->second.first);
     }
 
     unsigned level2_current_count(const irep_idt &identifier) const
     {
       level2t::current_namest::const_iterator it=
         level2_current_names.find(identifier);
-      return it==level2_current_names.end()?0:it->second;
-    }
-
-    irep_idt level2_current_name(const irep_idt &identifier) const
-    {
-      return id2string(identifier)+"#"+i2string(level2_current_count(identifier));
+      return it==level2_current_names.end()?0:it->second.second;
     }
   };
 
@@ -305,8 +235,8 @@ public:
 
     renaming_levelt::current_namest old_level1;
     
-    typedef std::set<irep_idt> local_variablest;
-    local_variablest local_variables;
+    typedef std::set<irep_idt> local_objectst;
+    local_objectst local_objects;
     
     framet():
       return_value(nil_exprt()),
@@ -368,9 +298,9 @@ public:
   // threads
   unsigned atomic_section_id;
   typedef std::pair<unsigned, std::list<guardt> > a_s_r_entryt;
-  typedef hash_map_cont<symbol_exprt, a_s_r_entryt, irep_hash> read_in_atomic_sectiont;
+  typedef hash_map_cont<ssa_exprt, a_s_r_entryt, irep_hash> read_in_atomic_sectiont;
   typedef std::list<guardt> a_s_w_entryt;
-  typedef hash_map_cont<symbol_exprt, a_s_w_entryt, irep_hash> written_in_atomic_sectiont;
+  typedef hash_map_cont<ssa_exprt, a_s_w_entryt, irep_hash> written_in_atomic_sectiont;
   read_in_atomic_sectiont read_in_atomic_section;
   written_in_atomic_sectiont written_in_atomic_section;
   
@@ -392,8 +322,8 @@ public:
   typedef std::vector<threadt> threadst;
   threadst threads;
   
-  bool l2_thread_read_encoding(symbol_exprt &expr, const namespacet &ns);
-  bool l2_thread_write_encoding(const symbol_exprt &expr, const namespacet &ns);
+  bool l2_thread_read_encoding(ssa_exprt &expr, const namespacet &ns);
+  bool l2_thread_write_encoding(const ssa_exprt &expr, const namespacet &ns);
 
   void switch_to_thread(unsigned t);
   bool record_events;
diff --git a/src/goto-symex/symex_atomic_section.cpp b/src/goto-symex/symex_atomic_section.cpp
index afdcccc..2cc46e4 100644
--- a/src/goto-symex/symex_atomic_section.cpp
+++ b/src/goto-symex/symex_atomic_section.cpp
@@ -64,9 +64,8 @@ void goto_symext::symex_atomic_end(statet &state)
       r_it!=state.read_in_atomic_section.end();
       ++r_it)
   {
-    symbol_exprt r=r_it->first;
-    r.set_identifier(
-      state.level2.name(r.get_identifier(), r_it->second.first));
+    ssa_exprt r=r_it->first;
+    r.set_level_2(r_it->second.first);
 
     // guard is the disjunction over reads
     assert(!r_it->second.second.empty());
@@ -91,8 +90,8 @@ void goto_symext::symex_atomic_end(statet &state)
       w_it!=state.written_in_atomic_section.end();
       ++w_it)
   {
-    symbol_exprt w=w_it->first;
-    state.level2(w);
+    ssa_exprt w=w_it->first;
+    w.set_level_2(state.level2.current_count(w.get_identifier()));
 
     // guard is the disjunction over writes
     assert(!w_it->second.empty());
diff --git a/src/goto-symex/symex_builtin_functions.cpp b/src/goto-symex/symex_builtin_functions.cpp
index eaf6344..e9cfc03 100644
--- a/src/goto-symex/symex_builtin_functions.cpp
+++ b/src/goto-symex/symex_builtin_functions.cpp
@@ -193,8 +193,9 @@ irep_idt get_symbol(const exprt &src)
   else if(src.id()==ID_address_of)
   {
     exprt op=to_address_of_expr(src).object();
-    if(op.id()==ID_symbol)
-      return to_symbol_expr(op).get_identifier();
+    if(op.id()==ID_symbol &&
+       op.get_bool(ID_C_SSA_symbol))
+      return to_ssa_expr(op).get_object_name();
     else
       return irep_idt();
   }
@@ -221,8 +222,6 @@ void goto_symext::symex_gcc_builtin_va_arg_next(
   
   if(id!=irep_idt())
   {
-    id=state.get_original_name(id);
-
     // strip last name off id to get function name
     std::size_t pos=id2string(id).rfind("::");
     if(pos!=std::string::npos)
diff --git a/src/goto-symex/symex_dead.cpp b/src/goto-symex/symex_dead.cpp
index 235bae5..7b77e9a 100644
--- a/src/goto-symex/symex_dead.cpp
+++ b/src/goto-symex/symex_dead.cpp
@@ -43,19 +43,9 @@ void goto_symext::symex_dead(statet &state)
   // We increase the L2 renaming to make these non-deterministic.
   // We also prevent propagation of old values.
   
-  const irep_idt &identifier=
-    to_symbol_expr(code.op0()).get_identifier();
-    
-  const irep_idt l1_identifier=
-    state.rename_identifier(identifier, ns, goto_symex_statet::L1);
-    
-  // prevent propagation
-  state.propagation.remove(l1_identifier);
+  ssa_exprt ssa(to_symbol_expr(code.op0()));
+  state.rename(ssa, ns, goto_symex_statet::L1);
 
-  // L2 renaming
-  unsigned new_count=state.level2.current_count(l1_identifier)+1;
-  state.level2.rename_identifier(l1_identifier, new_count);
-    
   // in case of pointers, put something into the value set
   if(ns.follow(code.op0().type()).id()==ID_pointer)
   {
@@ -74,10 +64,18 @@ void goto_symext::symex_dead(statet &state)
     else
       rhs=exprt(ID_invalid);
     
-    symbol_exprt l1_lhs;
-    l1_lhs.type()=code.op0().type();
-    l1_lhs.set_identifier(l1_identifier);
     state.rename(rhs, ns, goto_symex_statet::L1);
-    state.value_set.assign(l1_lhs, rhs, ns, true, false);
+    state.value_set.assign(ssa, rhs, ns, true, false);
   }
+
+  ssa_exprt ssa_lhs=to_ssa_expr(ssa);
+  const irep_idt &l1_identifier=ssa_lhs.get_identifier();
+
+  // prevent propagation
+  state.propagation.remove(l1_identifier);
+
+  // L2 renaming
+  if(state.level2.current_names.find(l1_identifier)!=
+     state.level2.current_names.end())
+    state.level2.increase_counter(l1_identifier);
 }
diff --git a/src/goto-symex/symex_decl.cpp b/src/goto-symex/symex_decl.cpp
index 9e94146..1c41040 100644
--- a/src/goto-symex/symex_decl.cpp
+++ b/src/goto-symex/symex_decl.cpp
@@ -43,27 +43,34 @@ void goto_symext::symex_decl(statet &state)
   if(code.op0().id()!=ID_symbol)
     throw "decl expects symbol as first operand";
 
+  symex_decl(state, to_symbol_expr(code.op0()));
+}
+
+/*******************************************************************\
+
+Function: goto_symext::symex_decl
+
+  Inputs:
+
+ Outputs:
+
+ Purpose:
+
+\*******************************************************************/
+
+void goto_symext::symex_decl(statet &state, const symbol_exprt &expr)
+{
   // We increase the L2 renaming to make these non-deterministic.
   // We also prevent propagation of old values.
   
-  const irep_idt &identifier=
-    to_symbol_expr(code.op0()).get_identifier();
-    
-  const irep_idt l1_identifier=
-    state.rename_identifier(identifier, ns, goto_symex_statet::L1);
-    
-  // prevent propagation
-  state.propagation.remove(l1_identifier);
+  ssa_exprt ssa(expr);
+  state.rename(ssa, ns, goto_symex_statet::L1);
 
-  // L2 renaming
-  unsigned new_count=state.level2.current_count(l1_identifier)+1;
-  state.level2.rename_identifier(l1_identifier, new_count);
-    
   // in case of pointers, put something into the value set
-  if(ns.follow(code.op0().type()).id()==ID_pointer)
+  if(ns.follow(expr.type()).id()==ID_pointer)
   {
     exprt failed=
-      get_failed_symbol(to_symbol_expr(code.op0()), ns);
+      get_failed_symbol(expr, ns);
     
     exprt rhs;
     
@@ -71,22 +78,29 @@ void goto_symext::symex_decl(statet &state)
     {
       address_of_exprt address_of_expr;
       address_of_expr.object()=failed;
-      address_of_expr.type()=code.op0().type();
+      address_of_expr.type()=expr.type();
       rhs=address_of_expr;
     }
     else
       rhs=exprt(ID_invalid);
     
-    symbol_exprt l1_lhs;
-    l1_lhs.type()=code.op0().type();
-    l1_lhs.set_identifier(l1_identifier);
     state.rename(rhs, ns, goto_symex_statet::L1);
-    state.value_set.assign(l1_lhs, rhs, ns, true, false);
+    state.value_set.assign(ssa, rhs, ns, true, false);
   }
   
-  // record the declaration
-  symbol_exprt original_lhs=to_symbol_expr(code.op0());
-  symbol_exprt ssa_lhs=original_lhs;
+  ssa_exprt ssa_lhs=to_ssa_expr(ssa);
+  const irep_idt &l1_identifier=ssa_lhs.get_identifier();
+
+  // prevent propagation
+  state.propagation.remove(l1_identifier);
+
+  // L2 renaming
+  // inlining may yield multiple declarations of the same identifier
+  // within the same L1 context
+  if(state.level2.current_names.find(l1_identifier)==
+     state.level2.current_names.end())
+    state.level2.current_names[l1_identifier]=std::make_pair(ssa_lhs, 0);
+  state.level2.increase_counter(l1_identifier);
   state.rename(ssa_lhs, ns);
 
   // we hide the declaration of auxiliary variables
diff --git a/src/goto-symex/symex_function_call.cpp b/src/goto-symex/symex_function_call.cpp
index 1e65769..9d498a5 100644
--- a/src/goto-symex/symex_function_call.cpp
+++ b/src/goto-symex/symex_function_call.cpp
@@ -383,11 +383,23 @@ void goto_symext::pop_frame(statet &state)
     state.level1.restore_from(frame.old_level1);
   
     // clear function-locals from L2 renaming
-    for(statet::framet::local_variablest::const_iterator
-        it=frame.local_variables.begin();
-        it!=frame.local_variables.end();
-        it++)
-      state.level2.remove(*it);
+    for(goto_symex_statet::renaming_levelt::current_namest::iterator
+        c_it=state.level2.current_names.begin();
+        c_it!=state.level2.current_names.end();
+       ) // no ++c_it
+    {
+      const irep_idt l1_o_id=c_it->second.first.get_l1_object_identifier();
+      // could use iteration over local_objects as l1_o_id is prefix
+      if(frame.local_objects.find(l1_o_id)==frame.local_objects.end())
+      {
+        ++c_it;
+        continue;
+      }
+      goto_symex_statet::renaming_levelt::current_namest::iterator
+        cur=c_it;
+      ++c_it;
+      state.level2.current_names.erase(cur);
+    }
   }
   
   state.pop_frame();
@@ -450,7 +462,9 @@ void goto_symext::locality(
       it++)
   {
     // get L0 name
-    irep_idt l0_name=state.rename_identifier(*it, ns, goto_symex_statet::L0);
+    ssa_exprt ssa(ns.lookup(*it).symbol_expr());
+    state.rename(ssa, ns, goto_symex_statet::L0);
+    const irep_idt l0_name=ssa.get_identifier();
 
     // save old L1 name for popping the frame
     statet::level1t::current_namest::const_iterator c_it=
@@ -463,19 +477,23 @@ void goto_symext::locality(
     // identifiers may be shared among functions
     // (e.g., due to inlining or other code restructuring)
     
-    irep_idt l1_name;
+    state.level1.current_names[l0_name]=
+      std::make_pair(ssa, frame_nr);
+    state.rename(ssa, ns, goto_symex_statet::L1);
+
+    irep_idt l1_name=ssa.get_identifier();
     unsigned offset=0;
     
-    do
+    while(state.l1_history.find(l1_name)!=state.l1_history.end())
     {
-      state.level1.rename_identifier(l0_name, frame_nr+offset);
-      l1_name=state.level1(l0_name);
-      offset++;
+      state.level1.increase_counter(l0_name);
+      ssa.set_level_1(frame_nr+offset);
+      l1_name=ssa.get_identifier();
+      ++offset;
     }
-    while(state.l1_history.find(l1_name)!=state.l1_history.end());
     
     // now unique -- store
-    frame.local_variables.insert(l1_name);
+    frame.local_objects.insert(l1_name);
     state.l1_history.insert(l1_name);
   }
 }
diff --git a/src/goto-symex/symex_goto.cpp b/src/goto-symex/symex_goto.cpp
index fa8baa3..5984d2d 100644
--- a/src/goto-symex/symex_goto.cpp
+++ b/src/goto-symex/symex_goto.cpp
@@ -137,7 +137,7 @@ void goto_symext::symex_goto(statet &state)
       exprt new_rhs=new_guard;
       new_rhs.make_not();
       
-      symbol_exprt new_lhs=guard_symbol_expr;
+      ssa_exprt new_lhs(guard_symbol_expr);
       state.rename(new_lhs, ns, goto_symex_statet::L1);
       state.assignment(new_lhs, new_rhs, ns, true, false);
       
@@ -293,19 +293,20 @@ void goto_symext::phi_function(
   statet &dest_state)
 {
   // go over all variables to see what changed
-  std::set<irep_idt> variables;
+  hash_set_cont<ssa_exprt, irep_hash> variables;
 
   goto_state.level2_get_variables(variables);
   dest_state.level2.get_variables(variables);
   
-  for(std::set<irep_idt>::const_iterator
+  for(hash_set_cont<ssa_exprt, irep_hash>::const_iterator
       it=variables.begin();
       it!=variables.end();
       it++)
   {
-    const irep_idt l1_identifier=*it;
+    const irep_idt l1_identifier=it->get_identifier();
+    const irep_idt &obj_identifier=it->get_object_name();
   
-    if(l1_identifier==guard_identifier)
+    if(obj_identifier==guard_identifier)
       continue; // just a guard, don't bother
       
     if(goto_state.level2_current_count(l1_identifier)==
@@ -314,23 +315,16 @@ void goto_symext::phi_function(
 
     // changed!
 
-    irep_idt original_identifier=
-      dest_state.get_original_name(l1_identifier);
-
     // shared variables are renamed on every access anyway, we don't need to
     // merge anything
-    const symbolt &symbol=ns.lookup(original_identifier);
+    const symbolt &symbol=ns.lookup(obj_identifier);
     
     // shared?
     if(dest_state.atomic_section_id==0 &&
        dest_state.threads.size()>=2 && symbol.is_shared())
       continue; // no phi nodes for shared stuff
     
-    // get type (may need renaming)      
-    typet type=symbol.type;
-    dest_state.rename(type, ns);
-    
-    exprt goto_state_rhs, dest_state_rhs;
+    exprt goto_state_rhs=*it, dest_state_rhs=*it;
 
     {
       goto_symex_statet::propagationt::valuest::const_iterator p_it=
@@ -339,7 +333,7 @@ void goto_symext::phi_function(
       if(p_it!=goto_state.propagation.values.end())
         goto_state_rhs=p_it->second;
       else
-        goto_state_rhs=symbol_exprt(goto_state.level2_current_name(l1_identifier), type);
+        to_ssa_expr(goto_state_rhs).set_level_2(goto_state.level2_current_count(l1_identifier));
     }
     
     {
@@ -349,7 +343,7 @@ void goto_symext::phi_function(
       if(p_it!=dest_state.propagation.values.end())
         dest_state_rhs=p_it->second;
       else
-        dest_state_rhs=symbol_exprt(dest_state.level2.current_name(l1_identifier), type);
+        to_ssa_expr(dest_state_rhs).set_level_2(dest_state.level2.current_count(l1_identifier));
     }
     
     exprt rhs;
@@ -365,7 +359,7 @@ void goto_symext::phi_function(
       // this gets the diff between the guards
       tmp_guard-=dest_state.guard;
       
-      rhs=if_exprt(tmp_guard.as_expr(), goto_state_rhs, dest_state_rhs, type);
+      rhs=if_exprt(tmp_guard.as_expr(), goto_state_rhs, dest_state_rhs);
       do_simplify(rhs);
     }
 
diff --git a/src/goto-symex/symex_main.cpp b/src/goto-symex/symex_main.cpp
index 7638eb4..e915c54 100644
--- a/src/goto-symex/symex_main.cpp
+++ b/src/goto-symex/symex_main.cpp
@@ -131,8 +131,9 @@ void goto_symext::rewrite_quantifiers(exprt &expr, statet &state)
     // we keep the quantified variable unique by means of L2 renaming
     assert(expr.operands().size()==2);
     assert(expr.op0().id()==ID_symbol);
-    irep_idt identifier=to_symbol_expr(expr.op0()).get_identifier();
-    state.level2.increase_counter(state.level1(identifier));
+    symbol_exprt tmp0=
+      to_symbol_expr(to_ssa_expr(expr.op0()).get_original_expr());
+    symex_decl(state, tmp0);
     exprt tmp=expr.op1();
     expr.swap(tmp);
   }
diff --git a/src/goto-symex/symex_start_thread.cpp b/src/goto-symex/symex_start_thread.cpp
index bd81a44..5ed474f 100644
--- a/src/goto-symex/symex_start_thread.cpp
+++ b/src/goto-symex/symex_start_thread.cpp
@@ -52,7 +52,7 @@ void goto_symext::symex_start_thread(statet &state)
   new_thread.pc=thread_target;
   new_thread.guard=state.guard;
   new_thread.call_stack.push_back(state.top());
-  new_thread.call_stack.back().local_variables.clear();
+  new_thread.call_stack.back().local_objects.clear();
   new_thread.call_stack.back().goto_state_map.clear();
   #if 0
   new_thread.abstract_events=&(target.new_thread(cur_thread.abstract_events));
@@ -61,29 +61,36 @@ void goto_symext::symex_start_thread(statet &state)
   // create a copy of the local variables for the new thread
   statet::framet &frame=state.top();
 
-  for(std::set<irep_idt>::const_iterator
-      it=frame.local_variables.begin();
-      it!=frame.local_variables.end();
-      it++)
+  for(goto_symex_statet::renaming_levelt::current_namest::const_iterator
+      c_it=state.level2.current_names.begin();
+      c_it!=state.level2.current_names.end();
+      ++c_it)
   {
+    const irep_idt l1_o_id=c_it->second.first.get_l1_object_identifier();
+    // could use iteration over local_objects as l1_o_id is prefix
+    if(frame.local_objects.find(l1_o_id)==frame.local_objects.end())
+      continue;
+
     // get original name
-    irep_idt original_name=state.get_original_name(*it);
-  
+    ssa_exprt lhs(c_it->second.first.get_original_expr());
+
     // get L0 name for current thread
-    irep_idt l0_name=state.level0.rename_identifier(original_name, t);
-    
+    lhs.set_level_0(t);
+
     // setup L1 name
-    state.level1.rename_identifier(l0_name, 0);
-    irep_idt l1_name=state.level1.current_name(l0_name);
+    if(!state.level1.current_names.insert(
+        std::make_pair(lhs.get_l1_object_identifier(),
+                       std::make_pair(lhs, 0))).second)
+      assert(false);
+    state.rename(lhs, ns, goto_symex_statet::L1);
+    const irep_idt l1_name=lhs.get_l1_object_identifier();
+    // store it
     state.l1_history.insert(l1_name);
+    new_thread.call_stack.back().local_objects.insert(l1_name);
 
-    // make sure the L2 name with current index exists for future renaming
-    state.level2(l1_name);
-    
     // make copy
-    typet type=ns.lookup(original_name).type;
-    symbol_exprt lhs(l1_name, type);
-    symbol_exprt rhs(*it, type);
+    ssa_exprt rhs=c_it->second.first;
+    state.rename(rhs, ns);
 
     guardt guard;
     symex_assign_symbol(state, lhs, nil_exprt(), rhs, guard, symex_targett::HIDDEN);
@@ -102,13 +109,10 @@ void goto_symext::symex_start_thread(statet &state)
       continue;
 
     // get original name
-    irep_idt original_name=symbol.name;
+    ssa_exprt lhs(symbol.symbol_expr());
 
     // get L0 name for current thread
-    irep_idt l0_name=state.level0.rename_identifier(original_name, t);
-
-    symbol_exprt lhs=symbol.symbol_expr();
-    lhs.set_identifier(l0_name);
+    lhs.set_level_0(t);
 
     exprt rhs=symbol.value;
     if(rhs.is_nil())
-- 
2.5.0

